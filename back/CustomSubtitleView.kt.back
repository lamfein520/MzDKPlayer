/*
 * Copyright 2025 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.mz.mzdkplayer.tool

import android.annotation.SuppressLint
import android.content.res.Configuration
import android.util.DisplayMetrics
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.DrawScope.Companion.DefaultBlendMode
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.semantics.contentDescription
import androidx.compose.ui.semantics.liveRegion
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.drawText
import androidx.compose.ui.text.rememberTextMeasurer
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.zIndex

import androidx.media3.common.text.Cue
import androidx.media3.common.text.CueGroup
import androidx.media3.common.util.Log
import androidx.media3.common.util.UnstableApi
import androidx.tv.material3.MaterialTheme
import kotlin.math.max

/**
 * A Material3 composable that renders subtitles provided by a [CueGroup] from Media3.
 *
 * This component displays both text and bitmap cues according to their layout properties
 * (e.g., position, size, anchor). Text cues are rendered using [Canvas], while bitmap cues
 * are rendered using [Canvas]. The subtitle area is aligned to the bottom center of the
 * provided layout space by default.
 *
 * Features:
 * - Safe null handling for all cue properties
 * - Accessibility support with content descriptions
 * - Configuration change handling (device rotation)
 * - Error boundary and recovery mechanisms
 *
 * Currently supports SRT, PSG, and ASS subtitles.
 * ASS subtitles are converted to SRT by ExoPlayer for display.
 * SRT subtitles with the same timestamp are displayed vertically in sequence.
 *
 * @param cueGroup The group of cues to display. If null or empty, nothing is rendered.
 * @param modifier The [Modifier] to be applied to the root layout.(Only affects SRT subtitles)
 * @param subtitleStyle The [TextStyle] used for rendering text cues. Defaults to
 *   [MaterialTheme.typography.bodyLarge] with white color and 18sp font size.(Only affects SRT subtitles)
 * @param backgroundColor The background color behind text cues. Defaults to fully
 *   transparent black ([Color.Black.copy(alpha = 0.0f)]).(Only affects SRT subtitles)
 * @param contentDescription The accessibility content description for the subtitle view.
 * @param isLiveRegion Whether the subtitle view should be treated as a live region for accessibility.
 * @param handleConfigurationChanges Whether to handle configuration changes like device rotation.
 *
 * @sample androidx.media3.ui.compose.material3.SubtitleViewSample
 *
 * Here is a basic usage example:
 *
 * ```
 * @Composable
 * fun VideoPlayerWithSubtitles(exoPlayer: ExoPlayer) {
 *   var currentCueGroup: CueGroup? by remember { mutableStateOf(null) }
 *
 *   DisposableEffect(exoPlayer) {
 *     val listener = object : Player.Listener {
 *       override fun onCues(cueGroup: CueGroup) {
 *         currentCueGroup = cueGroup
 *       }
 *     }
 *     exoPlayer.addListener(listener)
 *     onDispose {
 *       exoPlayer.removeListener(listener)
 *     }
 *   }
 *
 *   Box {
 *     // Your video surface or PlayerView here
 *     SubtitleView(
 *       cueGroup = currentCueGroup,
 *       subtitleStyle = MaterialTheme.typography.bodyLarge.copy(
 *         color = Color.White,
 *         fontSize = 20.sp
 *       ),
 *       backgroundColor = Color.Black.copy(alpha = 0.5f),
 *       contentDescription = "Video subtitles",
 *       isLiveRegion = true,
 *       modifier = Modifier.align(Alignment.BottomCenter)
 *     )
 *   }
 * }
 * ```
 */
@Composable
@UnstableApi
fun SubtitleView(
    cueGroup: CueGroup?,
    modifier: Modifier = Modifier,
    subtitleStyle: TextStyle = MaterialTheme.typography.bodyLarge.copy(
        color = Color.White,
        fontSize = 18.sp
    ),
    backgroundColor: Color = Color.Black.copy(alpha = 0.0f),
    contentDescription: String? = null,
    isLiveRegion: Boolean = false,
    handleConfigurationChanges: Boolean = true
) {
    // Error boundary state
    var lastError by remember { mutableStateOf<String?>(null) }

    // Configuration and screen dimensions
    val configuration = LocalConfiguration.current
    val context = LocalContext.current

    val screenDimensions = remember(configuration) {
        getScreenDimensions(context)
    }

    // Remember cue group with configuration dependency
    val rememberedCueGroup = remember(cueGroup, configuration.orientation) {
        cueGroup
    }

    // Filter valid cues
    val visibleCues by remember(rememberedCueGroup) {
        derivedStateOf {
            rememberedCueGroup?.cues?.filter { cue ->
                cue.text?.toString()?.isNotEmpty() == true || cue.bitmap != null
            } ?: emptyList()
        }
    }

    // Handle configuration changes
    LaunchedEffect(configuration.orientation) {
        if (handleConfigurationChanges) {
            Log.d("SubtitleView", "Orientation changed to: ${configuration.orientation}")
        }
    }

    // Error recovery
    LaunchedEffect(lastError) {
        lastError?.let { error ->
            Log.w("SubtitleView", "Recovered from error: $error")
            lastError = null
        }
    }

    // Early return if no cues to display
    if (visibleCues.isEmpty()) {
        return
    }

    // Build accessibility text
    val subtitleText = remember(visibleCues) {
        visibleCues.joinToString(", ") { cue ->
            cue.text?.toString()?.takeIf { it.isNotEmpty() && it != "null" } ?: ""
        }.trim().takeIf { it.isNotEmpty() }
    }

    // Layout modifier based on orientation
    val layoutModifier = if (handleConfigurationChanges) {
        when (configuration.orientation) {
            Configuration.ORIENTATION_LANDSCAPE -> modifier.padding(vertical = 4.dp)
            else -> modifier.padding(horizontal = 16.dp, vertical = 8.dp)
        }
    } else {
        modifier.padding(horizontal = 16.dp, vertical = 8.dp)
    }

    // Use SafeSubtitleContent to handle rendering errors
    SafeSubtitleContent(
        visibleCues = visibleCues,
        screenDimensions = screenDimensions,
        subtitleStyle = subtitleStyle,
        backgroundColor = backgroundColor,
        layoutModifier = layoutModifier,
        contentDescription = contentDescription,
        subtitleText = subtitleText,
        isLiveRegion = isLiveRegion,
        configuration = configuration,
        lastError = lastError,
        onError = { error ->
            lastError = error
        }
    )
}

@Composable
@UnstableApi
private fun SafeSubtitleContent(
    visibleCues: List<Cue>,
    screenDimensions: Pair<Int, Int>,
    subtitleStyle: TextStyle,
    backgroundColor: Color,
    layoutModifier: Modifier,
    contentDescription: String?,
    subtitleText: String?,
    isLiveRegion: Boolean,
    configuration: Configuration,
    lastError: String?,
    onError: (String) -> Unit
) {
    // Handle rendering errors with LaunchedEffect instead of try-catch
    LaunchedEffect(lastError) {
        lastError?.let { error ->
            Log.e("SubtitleView", "Rendering error: $error")
        }
    }

    Box(
        modifier = layoutModifier
            .semantics {
                contentDescription?.let {
                    this.contentDescription = it
                } ?: run {
                    subtitleText?.let {
                        this.contentDescription = "字幕: $it"
                    }
                }
                if (isLiveRegion) {
                    this.liveRegion = androidx.compose.ui.semantics.LiveRegionMode.Polite
                }
            },
        contentAlignment = Alignment.BottomCenter
    ) {
        when (configuration.orientation) {
            Configuration.ORIENTATION_LANDSCAPE -> {
                LandscapeSubtitleContent(
                    cues = visibleCues,
                    screenDimensions = screenDimensions,
                    subtitleStyle = subtitleStyle,
                    backgroundColor = backgroundColor,
                    onError = onError
                )
            }
            else -> {
                PortraitSubtitleContent(
                    cues = visibleCues,
                    screenDimensions = screenDimensions,
                    subtitleStyle = subtitleStyle,
                    backgroundColor = backgroundColor,
                    onError = onError
                )
            }
        }
    }
}

@Composable
@UnstableApi
private fun PortraitSubtitleContent(
    cues: List<Cue>,
    screenDimensions: Pair<Int, Int>,
    subtitleStyle: TextStyle,
    backgroundColor: Color,
    onError: (String) -> Unit
) {
    val textMeasurer = rememberTextMeasurer()
    val (screenWidthDp, screenHeightDp) = screenDimensions

    // Safe screen dimensions
    val safeScreenWidth = max(screenWidthDp, 1)
    val safeScreenHeight = max(screenHeightDp, 1)

    Column(
        verticalArrangement = Arrangement.spacedBy(4.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        cues.forEach { cue ->
            RenderCue(
                cue = cue,
                safeScreenWidth = safeScreenWidth,
                safeScreenHeight = safeScreenHeight,
                textMeasurer = textMeasurer,
                subtitleStyle = subtitleStyle,
                backgroundColor = backgroundColor,
                onError = onError
            )
        }
    }
}

@Composable
@UnstableApi
private fun LandscapeSubtitleContent(
    cues: List<Cue>,
    screenDimensions: Pair<Int, Int>,
    subtitleStyle: TextStyle,
    backgroundColor: Color,
    onError: (String) -> Unit
) {
    val textMeasurer = rememberTextMeasurer()
    val (screenWidthDp, screenHeightDp) = screenDimensions

    // Safe screen dimensions
    val safeScreenWidth = max(screenWidthDp, 1)
    val safeScreenHeight = max(screenHeightDp, 1)

    Column(
        verticalArrangement = Arrangement.spacedBy(2.dp), // Reduced spacing for landscape
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        cues.forEach { cue ->
            RenderCue(
                cue = cue,
                safeScreenWidth = safeScreenWidth,
                safeScreenHeight = safeScreenHeight,
                textMeasurer = textMeasurer,
                subtitleStyle = subtitleStyle,
                backgroundColor = backgroundColor,
                onError = onError
            )
        }
    }
}

@Composable
@UnstableApi
private fun RenderCue(
    cue: Cue,
    safeScreenWidth: Int,
    safeScreenHeight: Int,
    textMeasurer: androidx.compose.ui.text.TextMeasurer,
    subtitleStyle: TextStyle,
    backgroundColor: Color,
    onError: (String) -> Unit
) {
    // Render text cue with error handling
    cue.text?.toString()?.takeIf { it.isNotEmpty() && it != "null" }?.let { text ->
        val textLayoutResult = try {
            textMeasurer.measure(
                text = text,
                style = subtitleStyle.copy(textAlign = TextAlign.Center)
            )
        } catch (e: Exception) {
            onError("Text measurement error for: $text - ${e.message}")
            return@let
        }

        Canvas(
            modifier = Modifier
                .padding(bottom = 8.dp)
                .background(backgroundColor)
                .width(with(LocalDensity.current) {
                    textLayoutResult.size.width.toDp()
                })
                .height(with(LocalDensity.current) {
                    textLayoutResult.size.height.toDp()
                })
                .semantics {
                    this.contentDescription = "字幕: $text"
                    this.liveRegion = androidx.compose.ui.semantics.LiveRegionMode.Polite
                }
        ) {
            try {
                drawText(
                    textLayoutResult = textLayoutResult,
                    color = subtitleStyle.color
                )
            } catch (e: Exception) {
                onError("Text drawing error: ${e.message}")
            }
        }
    }

    // Render bitmap cue with error handling
    cue.bitmap?.let { bitmap ->
        val calculatedValues = try {
            // Safe bitmap dimensions calculation
            val bitmapWidth = if (cue.size != Cue.DIMEN_UNSET && cue.size > 0) {
                (safeScreenWidth * cue.size).toFloat()
            } else {
                bitmap.width.toFloat()
            }.coerceAtLeast(1f)

            val bitmapHeight = if (cue.bitmapHeight != Cue.DIMEN_UNSET && cue.bitmapHeight > 0) {
                (safeScreenHeight * cue.bitmapHeight).toFloat()
            } else {
                bitmap.height.toFloat()
            }.coerceAtLeast(1f)

            // Safe position calculation with defaults
            val position = cue.position.takeIf {
                it != Cue.DIMEN_UNSET
            } ?: 0.5f // Default center

            val line = cue.line.takeIf {
                it != Cue.DIMEN_UNSET
            } ?: 0.9f // Default bottom

            // Calculate offsets with bounds checking
            val offsetX = calculateHorizontalOffset(
                position = position,
                anchor = cue.positionAnchor,
                screenWidth = safeScreenWidth,
                elementWidth = bitmapWidth
            ).coerceIn(0f, safeScreenWidth.toFloat())

            val offsetY = calculateVerticalOffset(
                line = line,
                anchor = cue.lineAnchor,
                screenHeight = safeScreenHeight,
                elementHeight = bitmapHeight
            ).coerceIn(0f, safeScreenHeight.toFloat())

            Triple(bitmapWidth, bitmapHeight, Pair(offsetX, offsetY))
        } catch (e: Exception) {
            onError("Bitmap calculation error: ${e.message}")
            return@let
        }

        val (bitmapWidth, bitmapHeight, offsets) = calculatedValues
        val (offsetX, offsetY) = offsets

        Box(
            modifier = Modifier
                .offset(x = (offsetX - 14).dp, y = (offsetY - 8).dp)
                .size(bitmapWidth.dp, bitmapHeight.dp)
                .zIndex(cue.zIndex.toFloat().coerceIn(-100f, 100f))
                .semantics {
                    this.contentDescription = "图形字幕"
                    // Remove isTraversalGroup as it's not available in current Compose version
                }
        ) {
            Canvas(modifier = Modifier.fillMaxSize()) {
                try {
                    val srcSize = IntSize(width = bitmap.width, height = bitmap.height)
                    val dstWidth = (bitmapWidth * density).toInt()
                    val dstHeight = (bitmapHeight * density).toInt()
                    val dstSize = IntSize(width = dstWidth, height = dstHeight)

                    drawImage(
                        image = bitmap.asImageBitmap(),
                        srcOffset = IntOffset.Zero,
                        srcSize = srcSize,
                        dstOffset = IntOffset.Zero,
                        dstSize = dstSize,
                        alpha = 1.0f,
                        blendMode = DefaultBlendMode
                    )
                } catch (e: Exception) {
                    onError("Bitmap drawing error: ${e.message}")
                }
            }
        }
    }
}

/**
 * Calculates horizontal offset based on position and anchor type.
 */
private fun calculateHorizontalOffset(
    position: Float,
    anchor: Int,
    screenWidth: Int,
    elementWidth: Float
): Float {
    return when (anchor) {
        Cue.ANCHOR_TYPE_START -> screenWidth * position
        Cue.ANCHOR_TYPE_MIDDLE -> (screenWidth * position) - (elementWidth / 2)
        Cue.ANCHOR_TYPE_END -> (screenWidth * position) - elementWidth
        else -> screenWidth * position
    }
}

/**
 * Calculates vertical offset based on line and anchor type.
 */
private fun calculateVerticalOffset(
    line: Float,
    anchor: Int,
    screenHeight: Int,
    elementHeight: Float
): Float {
    return when (anchor) {
        Cue.ANCHOR_TYPE_START -> screenHeight * line
        Cue.ANCHOR_TYPE_MIDDLE -> (screenHeight * line) - (elementHeight / 2)
        Cue.ANCHOR_TYPE_END -> (screenHeight * line) - elementHeight
        else -> screenHeight * line
    }
}

/**
 * Returns the current screen dimensions in dp.
 *
 * @return A [Pair] of [Int] values representing the screen width and height in dp.
 */
private fun getScreenDimensions(context: android.content.Context): Pair<Int, Int> {
    val displayMetrics: DisplayMetrics = context.resources.displayMetrics
    val widthDp = (displayMetrics.widthPixels / displayMetrics.density).toInt()
    val heightDp = (displayMetrics.heightPixels / displayMetrics.density).toInt()
    return Pair(widthDp, heightDp)
}